структура SKLib

не использует throw (!)
использует STL при компиляции под современные операционки

версия для микроконтроллера использует "отжимку", т.е. нельзя
работать с файлами, нельзя динамическую память, что еще?
включить этот режим - определить макро SKLIB_TARGET_MCU
перед включением sklib.hpp

дополнительное таргетирование
SKLIB_TARGET_TEST  - включает некоторые "левые" функции специально для тестов
SKLIB_TARGET_QT    - (на будущее) включает транслятор QT, много специальных функций
SKLIB_TARGET_ATMEL - (не будущее) включает функции, специфичные для чипов Atmel, также включает SKLIB_TARGET_MCU

normal address to SKLib functions: sklib::что_то...

headers only, для включения в проект пользователя
втч библиотечные модули(!)


расширение - что_то.hpp
суффикс и расширение заголовка для включения в отдельный юнит компиляции - что_то-code.hpp
- пояснение: когда функционал библиотеки пользуется системными вызовами, включение системных
заголовков приводит к появлению множества имен в глобальной видимости, которые могут мешать
одним способом решения проблемы является компилирование библиотеки, которая содержит все
сисетмные вызовы внутри, а наружу показывает только интерфейс.
Этого же эффекта можно добиться, если в проекте, использующем библиотеку, назначен
специальный пустой файл, в котором стоит единственная команда: #include "что_то-code.hpp"
Это будет отдельный юнит компиляции, выполняющий ту же функцию, что и линкуемая библиотека.
Файл "что_то-code.hpp" содетжит внутри себя загрузку заголовка "что_то.hpp", таким
образом, все вместе может экспортировать функционал, заявленный в заголовке.

#define - в некоторых важных случаях допустимо использвать глобальные объявления
в этом случае имя должно быть совершенно наверняка уникальным
записывается заглавными буквами:
SKLIB_<НАЗВАНИЕ ГРУППЫ>_<НАЗВАНИЕ_ФУНКЦИИ>

могут быть исключения когда #define используется как основной функциональный мотив/элемент

здесь и далее, название группы - одно слово
название функции (класса, переменной, итп) - может быть несколько слов, разделенных знаками подчеркивания

используется преимущественно стиль snake, второй выбор - PascalCase.
стиль должен выдерживаться, как минимум, на протяжении одного логического абзаца,
но лучше - на протяжении всей функции, группы сходных функций, класса, группы сходных классов

специальные имена: is_чтото, can_чтото, has_чтото, итп, всегда с маленькой буквы

для обозначения типов используется суффикс _type (чтобы избежать конфликта с суффиксом _t)
так же - для имен классов, которыми можно пользоваться в качестве типов
для PascalCase - суффикс Type

namespace sklib - основная библиотека, может быть распределена по нескольким файлам

в ней:
1) все функции, классы, и объявления, предназначенные для _штатной_ работы модуля
структура имени: <название группы>_<название функции>, например: bits_flip()
вызов: sklib::bits_flip(); внутренний референс: ::sklib::bits_flip()

2) namespace opaque внутри sklib
все имена, классы, итд, вспомогательного характера, которые нужны только для
обеспечения работоспособности библиотеки

3) namespace supplement внутри sklib
функции итп, которые непосредственно не нужны для работы библиотеки, но могут использоваться
для проверки работоспособности, генерации статических таблиц, итп
NB! промежуточные типы данных, которые не используются непосредственно - тоже supplement 

сюда же относятся объекты/операции/идеи, выходящие за рамки заявленного функционала,
но потенциально полезные для использования

если функция должна оказаться в opaque, но она также может пойти в supplement,
выбирается supplement


